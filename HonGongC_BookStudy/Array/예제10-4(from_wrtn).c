#include <stdio.h> // 입출력 함수 쓰려고 불러왔어!

int main(void) {
    int ary[5] = {10, 20, 30, 40, 50}; // int형 정수 5개를 담을 수 있는 'ary'라는 이름의 배열을 만들고 값도 넣어줬네!
    int *pa = ary;  // 'pa'라는 int형 포인터를 만들고, 'ary'의 시작 주소를 넣어줬어.
                    // 여기서 'ary'는 배열 이름인데, 포인터처럼 쓰면 배열의 첫 번째 요소(ary[0])의 주소를 가리키게 돼!
    int *pb = pa + 3;  // 'pb'라는 int형 포인터를 만들고, 'pa' 주소에서 3칸(int 크기만큼) 뒤로 간 주소를 넣어줬어.
                     // 'pa'가 ary[0]을 가리키니까, 'pa + 3'은 ary[3]의 주소를 가리키게 되는 거지! (10, 20, 30, 40 -> 40의 주소!)

    printf("pa : %u\n", pa); // 'pa'가 가지고 있는 주소 값을 출력해! ary[0]의 주소가 나올 거야.
    printf("pb : %u\n", pb); // 'pb'가 가지고 있는 주소 값을 출력해! ary[3]의 주소가 나올 거야.

    pa++;  // 'pa'를 다음 배열 요소로 이동시켜! 'pa'가 원래 ary[0]을 가리켰는데, 이제 ary[1]을 가리키게 돼! (20의 주소!)
           // 포인터에 ++를 하면, 포인터가 가리키는 자료형의 크기만큼 주소가 늘어나! int는 보통 4바이트니까 주소가 4 늘어나는 거지.

    printf("pb - pa : %u\n", pb - pa);  // 'pb' 주소에서 'pa' 주소를 뺀 값을 출력해.
                                      // 여기서 중요한 건, 포인터끼리 빼면 주소 차이가 아니라 '몇 개의 요소'가 떨어져 있는지 나와!
                                      // 'pb'는 ary[3]을 가리키고, 'pa'는 이제 ary[1]을 가리키잖아?
                                      // 그럼 ary[1]부터 ary[3]까지는 (ary[2], ary[3]) 2개의 요소가 떨어져 있지? 그래서 결과는 '2'가 나와!

    printf("앞에 있는 배열 요소의 값 출력 : ");
    if (pa < pb) printf("%d\n", *pa);   // 'pa' 주소가 'pb' 주소보다 작으면 (즉, pa가 pb보다 배열 앞쪽에 있으면)
                                        // 'pa'가 가리키는 값(*pa)을 출력해.
                                        // 'pa'는 ary[1]을 가리키고, 'pb'는 ary[3]을 가리키니까 pa 주소가 더 작을 거야.
                                        // 그래서 이 조건문은 참이 돼서 'pa'가 가리키는 값, 즉 ary[1]의 값인 '20'이 출력될 거야!
    else printf("%d\n", *pa); // 만약 pa 주소가 pb 주소보다 크거나 같으면 *pa를 출력...인데,
                              // 위 if 조건이 참이라 여기는 실행 안 돼. 그리고 사실 if랑 else 둘 다 *pa를 출력하게 되어 있어서 똑같아! 😂

    return 0; // 프로그램 잘 끝났다고 알려주는 거야!
}
